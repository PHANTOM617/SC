framework for build shellcode

**prepare**


this is util dll project. it process map file for PE, from which we want create shellcode, and create ,based on it, special asm file ( x64/x86 ) for implement import
(assume that we use only extern "C" imported functions with __stdcall/__cdecl calling conventions)
it save shellcode in 3 possible formats: 

- as raw binary, 
- as asm file for masm[64] input  (DQ instructions)
- as exe (without imports and relosc, for easy demo/test)

also it check that shellcode containing no relocs, otherwise return error (`STATUS_ILLEGAL_DLL_RELOCATION`)

we use prepare on post build event and usually we need run it 2 time:
on first run it check for import, in PE (shellcode of course must not have import), if exist - process it with map file and return error `STATUS_MORE_PROCESSING_REQUIRED`
after this we need recompile our asm file (which include generated import) and build second time.
if no errors - on second post build we got ready shellcode

**ScEntry**


static lib. this is mini "crt" for shellcode project. we need add `ScEntry.lib` to linker input, and set entry point of our project to
`?ScEntry@@YAXPEAU_PEB@@@Z` (x64) or `?ScEntry@@YGXPAU_PEB@@@Z` (x86)
the our "user" entry point will be `?epASM@@YGXPAU_PEB@@@Z` (x86) or `?epASM@@YAXPEAU_PEB@@@Z` (x64)

this is like `wWinMainCRTStartup` (real exe entry point in crt code) and `wWinMain` ("user" entry point, called from `wWinMainCRTStartup`) relationship

`?epASM@@Y**PAU_PEB@@@Z` usually "call" c/c++ entry point with simply jmp

sense of exist separate asm entry - in case shellcode entry point must be at very begin - at 0 offset of shellcode body and with asm we can implement this condition

**ScEntry** wil be statically link to our exe shellcode project. part of it code ( from [*GetFuncAddr.cpp*](ScEntry/GetFuncAddr.cpp) - `GetFuncAddressEx`, `get_hmod`, `GetNtBase` ) will be in final shellcode and
used for transparent resolve import (in most case for this not need be write any "user" code). and part ( [*prepare.cpp*](ScEntry/prepare.cpp) ) will be used for convert PE to shellcode and will be not part of final shellcode


now, after this 2 util projects, we can start our custom project, for create shellcode from it

several requirements for project:

put all code in `[ ".text$mn", ".text$zz" )` range

this let ScEntry exactly found begin/end of shellcode range

usually put all own c/c++ code in `#pragma code_seg(".text$mn$cpp")` section.
include this `#pragma` at very begin (before include any headers, which can have inline functions, NtCurrentTeb() as example)
and asm code simply in `.code` section ( this will be `".text$mn"` if use masm[64] compiler )

at very begin of asm code, put `?epASM@@Y**PEAU_PEB@@@Z` procedure (it musr be first code/data !)
which usually simply jmp to your c/c++ code

include then
```
include <../scentry/nobase[32/64].inc>

include <imp.asm>
```
the imp.asm, let be initial empty file (it will be autogenerated after first post-build by prepare.dll)

usually in most case your content of asm file will be very minimal and standard
```
.code

; void __stdcall ep(struct _PEB *)
extern ?ep@@YAXPEAU_PEB@@@Z : PROC

; void __cdecl epASM(struct _PEB *)
?epASM@@YAXPEAU_PEB@@@Z proc
	jmp ?ep@@YAXPEAU_PEB@@@Z
?epASM@@YAXPEAU_PEB@@@Z endp

include <..\scentry\nobase64.inc>

include <imp.asm>

end
```
strings:

use `/cbstring` option for compiler (CL.exe (more known as msvc)) in x64 mode.
this put strings to `".text$mn$cpp$s"` section - more general if your code in `"X"` section use some strings - it will be put to `"X$s"` section.
the reference to strings to create relocs in x64 mode. so only what we need here `/cbstring` option

in case x86, use strings generate relocations, so we can not use it direct from c/c++ ( even with /cbstring )
so we need put it in asm as functions, which return string. use createWstring, createAstring macros, for use strings

look for example in [*SCx86\x86.asm*](SCx86/x86.asm)

say
```
createWstring ?host@@YGPB_WXZ, <the.earth.li>
```

create function
```
const wchar_t *__stdcall host()
```
which return
```
L"the.earth.li"
```
string

restrictions - we can not use global variables and virtual functions ( vtable is global array with pointers to functions, which always generate relocations, even in x64 mode)
despite if we very want use it, possible do something with asm support ( look for demo in dcom\x64.asm and dcom\import.cpp )

mandatory set option for linker generate map file ( `/MAP` )

we need override `DECLSPEC_IMPORT` macro - must be translated to empty, not to `__declspec(dllimport)` (mandatory and critical condition)
possible (`_CRTIMP`, `_CRTIMP_ALT`, `DPAPI_IMP`, etc) - rarelly, only if you use api with this macros

not forget `/cbstring` (compiler), `/ENTRY:"?ScEntry@@Y**PEAU_PEB@@@Z"`, `"ScEntry.lib"`, `/MAP` (linker)

mandatory set post build step:

something like
```
"$(TargetPath)" *$(OutDir)$(ProjectName).map*imp.asm*..\$(ProjectName).bin*..\$(ProjectName).asm*..\$(ProjectName).exe
```
(yes, we exec own exe file (2 time) at post-build, for generate shellcode)

and main - you mast very deep understand compiler, linker, windows and all what you doing.

